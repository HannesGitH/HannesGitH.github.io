<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="./favicon.png" />
		<meta name="viewport" content="width=device-width" />

		<!-- Material Icons -->
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
		<!-- Roboto -->
		<link
			rel="stylesheet"
			href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700"
		/>
		<!-- Roboto Mono -->
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>
		<!-- SMUI Styles -->
		<link rel="stylesheet" href="/smui.css" media="(prefers-color-scheme: light)" />
		<link rel="stylesheet" href="/smui-dark.css" media="screen and (prefers-color-scheme: dark)" />

		<!-- DEV ICONS -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@v2.15.1/devicon.min.css"> 
		<script>
			var module = {};
		</script>
		<meta http-equiv="content-security-policy" content="">
		<link href="./_app/immutable/assets/_page-4cc8023b.css" rel="stylesheet">
		<link href="./_app/immutable/assets/iconwithblob-919bda81.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/start-badb6dfc.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/preload-helper-aa6bc0ce.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index-3ab74435.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/singletons-c4f97876.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index-5bbdb34d.js">
		<link rel="modulepreload" href="./_app/immutable/components/layout.svelte-dec2f24c.js">
		<link rel="modulepreload" href="./_app/immutable/modules/pages/_layout.ts-ee17a131.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/runtime.esm-ebacd809.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/_layout-74980f65.js">
		<link rel="modulepreload" href="./_app/immutable/components/pages/_page.svelte-a9330ea9.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/en-4f74be34.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/de-4fc73553.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/iconwithblob-85b9f66f.js">
	</head>
	<body>
		<div>


<div id="wrapper" style="--offset-top: 0px;" class="svelte-19u39mq"><p id="lorem">  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;  !function ( t, n ) &amp;#123;&amp;quot;object&amp;quot; =  = typeof  ( t.flubber2 = &amp;#123;&amp;#125; ) &amp;#125; ( this, function ( t ) &amp;#123;&amp;quot;use strict&amp;quot;;function n ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[1]*i[0]-n[0]*i[1];return a/2&amp;#125;function o/h]&amp;#125;function function #123;switch ( 32|t ) &amp;#123;case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0&amp;#125;return!1&amp;#125;function o ( t ) &amp;#123;return 97 =  =  ( 32|t ) &amp;#125;function s ( t ) &amp;#123;return t&amp;gt; = 48&amp;amp;&amp;amp;t&amp;lt; = 57&amp;#125;function h ( t ) &amp;#123;return  ( t ) &amp;#123;var n = t.path.charCodeAt ( t.index ) ;return 48 =  =  = n? ( t.param = 0, void t.index++ ) :49 =  =  = n? ( t.param = 1, void t.index++ ) :void ( t.err = &amp;quot;SvgPath: arc flag can be 0 or 1 only  ( at pos &amp;quot;+t.index+&amp;quot; ) &amp;quot; ) &amp;#125;function l ( t ) &amp;#123;var n, e = t.index, r = e, i = t.max, a = !1, o = !1, h = !1, u = !1;if ( r&amp;gt; = i ) return void ( t.err = &amp;quot;SvgPath: missed param  ( at err = &amp;quot;SvgPath: param should start with 0..9 or &amp;#96;.&amp;#96;  ( at quot;SvgPath: numbers started with &amp;#96;0&amp;#96; such as &amp;#96;09&amp;#96; are illegal  ( at pos  ( r )  ) ; ) r++, h = !0;n = r&amp;lt;i?t.path.charCodeAt ( r ) :0&amp;#125;if ( 101 =  =  = n||69 =  =  = n ) &amp;#123;if ( u&amp;amp;&amp;amp;!o&amp;amp;&amp;amp;!h ) return void ( t.err = &amp;quot;SvgPath: invalid float exponent  ( at err = &amp;quot;SvgPath: invalid float exponent  ( at #123;var  ( n )  ) return void ( t.err = &amp;quot;SvgPath: bad command &amp;quot;+t.path[t.index]+&amp;quot;  ( at *n[0]+t[2]*n[1], t[1]*n[0]+t[3]*n[1], t[0]*n[2]+t[2]*n[3], t[1]*n[2]+t[3]*n[3], t[0]*n[4]+t[2]*n[5]+t[4], t[1]*n[4]+t[3]*n[5]+t[5]]&amp;#125;function x (  ) &amp;#123;if ( ! ( this instanceof x )  ) return new x;this.queue = [], this.cache = null&amp;#125;function y ( t, n, e, r ) &amp;#123;var return[r, i, r-i*e, i+r*e, a+o*e, o-a*e, a, o]&amp;#125;function M ( t, n, e ) &amp;#123;if ( ! ( this instanceof M )  ) return new M ( t, n, e ) ;this.rx = t, this.ry = n, this.ax = e&amp;#125;function w ( t ) &amp;#123;if ( ! ( this instanceof w )  ) return new w ( t ) ;var n = En ( t ) ;this.segments = n.segments, this.err = n.err, this.__stack = []&amp;#125;function b ( t ) &amp;#123;var n = [];return t.replace ( Dn, function ( t, e, r ) &amp;#123;var quot;L&amp;quot; ) ;r.length&amp;gt; = 0; ) &amp;#123;if ( r.length =  =  = On[i] ) return r.unshift ( e ) , n.push ( r ) ;if ( r.length&amp;lt;On[i] ) throw new Error ( &amp;quot;malformed path data&amp;quot; ) ;n.push ( [e].concat ( r.splice ( 0, On[i] )  )  ) &amp;#125;&amp;#125; ) , n&amp;#125;function L ( t ) &amp;#123;var n = t.match ( Hn ) ;return n?n.map ( Number ) :[]&amp;#125;function A ( t, n, e, r, i, a, o, s ) &amp;#123;return #125;function P ( t, n, e, r, i ) &amp;#123;for ( var nbsp;+e*e*e*n[3]&amp;#125;&amp;#125;function C ( t, n, e ) &amp;#123;void  ( Math.abs (  ( l+Math.sqrt ( l*l+p )  ) / ( c+Math.sqrt ( c*c+p )  )  )  )  ) &amp;#125;function Z ( t, n ) &amp;#123;return Un[t][n]&amp;#125;function T ( t, n, e ) &amp;#123;var r, i, a, o = e.length-1;if ( 0 =  =  = o ) return 0;if ( 0 =  =  = t ) &amp;#123;for ( i = 0, a = 0;a&amp;lt; = o;a++ ) i+ = Z ( o, a ) *Math.pow ( 1-n, o-a ) *Math.pow ( n, a ) *e[a];return i&amp;#125;for ( r = new Array ( o ) , a = 0;a&amp;lt;o;a++ ) r[a] = o* ( e[a+1]-e[a] ) ;return T ( t-1, n, r ) &amp;#125;function F ( t, n, e ) &amp;#123;var r = T ( 1, e, t ) , i = T ( 1, e, n ) , a = r*r+i*i;return Math.sqrt ( a ) &amp;#125;function z ( t, n, e ) &amp;#123;var r, i, a, o;void 0 =  =  = e&amp;amp;&amp;amp; ( e = 1 ) ;for ( r = e/2, i = 0, a = 0;a&amp;lt;20;a++ ) o = r*Nn[20][a]+r, i+ = Qn[20][a]*F ( t, n, o ) ;return r*i&amp;#125;function j ( t, n, e, r ) &amp;#123;var + = y;return g.map ( function ( t ) &amp;#123;for ( var n = 0;n&amp;lt;t.length;n+ = 2 ) &amp;#123;var i = t[n+0], a = t[n+1];i* = e, a* = r;var o = c*i-u*a, s = u*i+c*a;t[n+0] = o+v[0], t[n+1] = s+v[1]&amp;#125;return t&amp;#125; ) &amp;#125;function Y ( t, n, e, r, i, a, o, s, h ) &amp;#123;return new G ( t, n, e, r, i, a, o, s, h ) &amp;#125;function G ( t, n, e, r, i, a, o, s, h ) &amp;#123;var  ( n ) &amp;#125; ) , this.length = u, this.partialLengths = c, this.curves = f&amp;#125;function O ( t, n, e, r ) &amp;#123;return new D ( t, n, e, r ) &amp;#125;function D ( t, n, e, r ) &amp;#123;this.x0 = t, this.x1 = n, this.y0 = e, this.y1 = r&amp;#125;function H ( t ) &amp;#123;function n ( t ) &amp;#123;if ( !t ) return [c][2], s[c][3], s[c][4], s[c][5], h[0]+s[c][6], h[1]+s[c][7] ) , e+ = a.getTotalLength (  ) , h = [h[0]+s[c][6], h[1]+s[c][7]], i.push ( a )  ) , r.push ( e ) ;return n&amp;#125;var e = 0, r = [], i = [];n.getTotalLength = function (  ) &amp;#123;return e&amp;#125;, n.getPointAtLength = function ( t ) &amp;#123;var #125;, n.getPropertiesAtLength = function ( t ) &amp;#123;var n = a ( t ) ;return n--;return n++, &amp;#123;fraction:t-r[n-1], i:n&amp;#125;&amp;#125;;return n ( t ) &amp;#125;function #125;function U ( t, n ) &amp;#123;return N ( t, n ) &amp;lt;1e-9&amp;#125;function R ( t, n, e ) &amp;#123;var r = t.map ( function ( t, e ) &amp;#123;return B ( t, n[e] ) &amp;#125; ) ;return function ( t ) &amp;#123;var n = r.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) ;return e?nt ( n ) :n&amp;#125;&amp;#125;function B ( t, n ) &amp;#123;return function ( e ) &amp;#123;return t.map ( function ( t, r ) &amp;#123;return t+e* ( n[r]-t ) &amp;#125; ) &amp;#125;&amp;#125;function W ( t ) &amp;#123;return&amp;quot;number&amp;quot; =  = typeof t&amp;amp;&amp;amp;isFinite ( t ) &amp;#125;function J ( t ) &amp;#123;return K ( t ) ?e ( t ) :[ ( t[0][0]+t[t.length-1][0] ) /2,  ( t[0][1]+t[t.length-1][1] ) /2]&amp;#125;function K ( t ) &amp;#123;for ( var #123;return new Gn ( t ) .abs (  ) &amp;#125;function return t&amp;#125; ) &amp;#125;function nt ( t ) &amp;#123;return&amp;quot;M&amp;quot;+t.join ( &amp;quot;L&amp;quot; ) +&amp;quot;Z&amp;quot;&amp;#125;function et ( t ) &amp;#123;return tt ( $ ( t )  ) &amp;#125;function rt ( t, n ) &amp;#123;var e = $ ( t ) ;return it ( e ) ||at ( e, n ) &amp;#125;function #123;var e, r, i = tt ( t ) [0], a = [], o = 3;if ( !i ) throw nbsp;n.setAttributeNS ( null, &amp;quot;d&amp;quot;, t ) , n&amp;#125;catch ( t ) &amp;#123;&amp;#125;return H ( t ) &amp;#125;function st ( t, n ) &amp;#123;for ( var + = c, a++ ) &amp;#125;&amp;#125;function ht ( t, n ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = 1/0 ) ;for ( var e = 0;e&amp;lt;t.length;e++ ) for ( var r = t[e], i = e =  =  = t.length-1?t[0]:t[e+1];N ( r, i ) &amp;gt;n; ) i = Q ( r, i, .5 ) , t.splice ( e+1, 0, i ) &amp;#125;function ut ( t, e ) &amp;#123;var r, i, a;if ( &amp;quot;string&amp;quot; =  = typeof t ) &amp;#123;var o = rt ( t, e ) ;t = o.ring, a = o.skipBisect&amp;#125;else if ( !Array.isArray ( t )  ) throw new TypeError ( Bn ) ;if ( r = t.slice ( 0 ) , !ct ( r )  ) throw new TypeError ( Bn ) ;return function ct ( t ) &amp;#123;return amp;&amp;amp; ( i = t.splice ( 0, e ) , t.splice.apply ( t, [t.length, 0].concat ( i )  )  ) &amp;#125;function lt ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = ut ( t, r ) , o = ut ( n, r ) , s = pt ( a, o, i ) ;return!i||&amp;quot;string&amp;quot;! = typeof t&amp;amp;&amp;amp;&amp;quot;string&amp;quot;! = typeof n?s:function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof t?t:1-e&amp;lt;1e-4&amp;amp;&amp;amp;&amp;quot;string&amp;quot; =  = typeof n?n:s ( e ) &amp;#125;&amp;#125;function pt ( t, n, e ) &amp;#123;var 1/p:0&amp;#125;return yt ( a, o, e, s, h, p ) , o&amp;#125;function o&amp;amp;&amp;amp;Ft ( o, o.next ) &amp;amp;&amp;amp; ( Dt ( o ) , o = o.next ) , o&amp;#125;function xt ( t, n ) &amp;#123;if ( !t ) return t;n|| ( n = t ) ;var r! =  = n ) ;return n&amp;#125;function e, r, i, a, 1 ) ;break&amp;#125;&amp;#125;&amp;#125;function dt ( t ) &amp;#123;var  = 0 ) return!1;i = i.next&amp;#125;return!0&amp;#125;function mt ( t, n, e, r ) &amp;#123;var #125;return!0&amp;#125;function Mt ( t, n, e ) &amp;#123;var r = t;do&amp;#123;var r = t = a ) , r = r.next&amp;#125;while ( r! =  = t ) ;return xt ( r ) &amp;#125;function wt ( t, n, e, r, i, a ) &amp;#123;var o = t;do&amp;#123;for ( var s = o.next.next;s! =  = o.prev; ) &amp;#123;if ( o.i! =  = s.i&amp;amp;&amp;amp;Zt ( o, s )  ) &amp;#123;var h = Gt ( o, s ) ;return o = xt ( o, o.next ) , h = xt ( h, h.next ) , yt ( o, n, e, r, i, a ) , void yt ( h, n, e, r, i, a ) &amp;#125;s = s.next&amp;#125;o = o.next&amp;#125;while ( o! =  = t ) &amp;#125;function bt ( t, n, e, r ) &amp;#123;var i = 0;i&amp;lt;u.length;i++ ) e = At ( u[i], e ) , e = xt ( e, e.next ) ;return e&amp;#125;function Lt ( t, n ) &amp;#123;return t.x-n.x&amp;#125;function At ( t, n ) &amp;#123;var e = kt ( t, n ) ;if ( !e ) return n;var r = Gt ( e, t ) , i = xt ( e, e.next ) ;return xt ( r, r.next ) , n =  =  = e?i:n&amp;#125;function #125;r = r.next&amp;#125;while ( r! =  = n ) ;if ( !e ) return null;if ( i =  =  = o ) return function qt ( t, n ) &amp;#123;return Tt ( t.prev, t, n.prev ) &amp;lt;0&amp;amp;&amp;amp;Tt ( n.next, t, t.next ) &amp;lt;0&amp;#125;function nextZ = null, u* = 2&amp;#125;while ( o&amp;gt;1 ) ;return t&amp;#125;function x ) - ( n.x-t.x ) * ( e.y-n.y ) &amp;#125;function Ft ( t, n ) &amp;#123;return t.x =  =  = n.x&amp;amp;&amp;amp;t.y =  =  = n.y&amp;#125;function amp;n.y&amp;lt; = Math.max ( t.y, e.y ) &amp;amp;&amp;amp;n.y&amp;gt; = Math.min ( t.y, e.y ) &amp;#125;function It ( t ) &amp;#123;return t&amp;gt;0?1:t&amp;lt;0?-1:0&amp;#125;function  ( t, t.next, n ) &amp;lt;0&amp;#125;function Yt ( t, n ) &amp;#123;var e = e.next&amp;#125;while ( e! =  = t ) ;return r&amp;#125;function Gt ( t, n ) &amp;#123;var e = new Ot ( t, n, e, r ) &amp;#123;var i = new next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1&amp;#125;function Nt ( t, n, e, r ) &amp;#123;for ( var i = 0, a = n, o = e-r;a&amp;lt;e;a+ = r ) i+ =  ( t[o]-t[a] ) * ( t[a+1]+t[o+1] ) , o = a;return i&amp;#125;function Qt ( t ) &amp;#123;return t&amp;#125;function Ut ( t ) &amp;#123;if ( null =  = t ) return Qt;var n, e, r = t.scale[0], i = t.scale[1], a = t.translate[0], o = t.translate[1];return function ( t, s ) &amp;#123;s|| ( n = e = 0 ) ;var h = 2, u = t.length, c = new Array ( u ) ;for ( c[0] =  ( n+ = t[0] ) *r+a, c[1] =  ( e+ = t[1] ) *i+o;h&amp;lt;u; ) c[h] = t[h], ++h;return c&amp;#125;&amp;#125;function #125; ) &amp;#125;:Wt ( t, n ) &amp;#125;function geometry:a&amp;#125;&amp;#125;function Jt ( t, n ) &amp;#123;function return h ( t ) &amp;#125;function i ( t ) &amp;#123;for ( var n = [], r = 0, i = t.length;r&amp;lt;i;++r ) e ( t[r], n ) ;return n.length&amp;lt;2&amp;amp;&amp;amp;n.push ( n[0] ) , n&amp;#125;function a ( t ) &amp;#123;for ( var n = i ( t ) ;n.length&amp;lt;4; ) n.push ( n[0] ) ;return n&amp;#125;function o ( t ) &amp;#123;return t.map ( a ) &amp;#125;function #125;&amp;#125;var h = Ut ( t.transform ) , u = t.arcs;return s ( n ) &amp;#125;function Kt ( t, n ) &amp;#123;function e ( n ) &amp;#123;var function r ( t, n ) &amp;#123;for ( var e in t ) &amp;#123;var r = t[e];delete n[r.start], delete return  ( function ( t ) &amp;#123;var n, r, i = e ( t ) , s = i[0], h = i[1];if ( n = o[s] ) if ( delete o[n.end], n.push ( t ) , n.end = h, r = a[h] ) &amp;#123;delete a[r.start];var u = r =  =  = n?n:n.concat ( r ) ;a[u.start = n.start] = o[u.end = r.end] = u&amp;#125;else a[n.start] = o[n.end] = n;else if ( n = a[h] ) if ( delete a[n.start], n.unshift ( t ) , n.start = s, r = o[s] ) &amp;#123;delete o[r.end];var c = r =  =  = n?n:r.concat ( n ) ;a[c.start = r.start] = o[c.end = n.end] = c&amp;#125;else nbsp;$t ( t ) &amp;#123;for ( var n, e = -1, r = t.length, i = t[r-1], a = 0;++e&amp;lt;r; ) n = i, i = t[e], a+ = n[0]*i[1]-n[1]*i[0];return Math.abs ( a ) &amp;#125;function  ( t ) &amp;#125; ) &amp;#125; ) , o.push ( t ) &amp;#125;function i ( n ) &amp;#123;return $t ( Jt ( t, &amp;#123;type:&amp;quot;Polygon&amp;quot;, arcs:[n]&amp;#125; ) .coordinates[0] ) &amp;#125;var a = &amp;#123;&amp;#125;, o = [], s = [];return [h], r[h] = s, u = o ) ;return r&amp;#125; ) .filter ( function ( t ) &amp;#123;return t.length&amp;gt;0&amp;#125; ) &amp;#125;&amp;#125;function nn ( t, n ) &amp;#123;for ( var e = 0, r = t.length;e&amp;lt;r; ) &amp;#123;var i = e+r&amp;gt;&amp;gt;&amp;gt;1;t[i]&amp;lt;n?e = i+1:r = i&amp;#125;return e&amp;#125;function type in o&amp;amp;&amp;amp;o[t.type] ( t.arcs, n ) &amp;#125;var  ( t, n ) &amp;#125; ) &amp;#125;&amp;#125;;t.forEach ( r ) ;for ( var s in i ) for ( var h = i[s], u = h.length, c = 0;c&amp;lt;u;++c ) for ( var #125;function rn ( t, n ) &amp;#123;return  ( null =  = r&amp;amp;&amp;amp; ( r = 0 ) , null =  = i&amp;amp;&amp;amp; ( i = n.length ) ;r&amp;lt;i; ) &amp;#123;var a = r+i&amp;gt;&amp;gt;&amp;gt;1;t ( n[a], e ) &amp;gt;0?i = a:r = a+1&amp;#125;return r&amp;#125;&amp;#125;&amp;#125;function on ( t ) &amp;#123;return function ( n, e ) &amp;#123;return rn ( t ( n ) , e ) &amp;#125;&amp;#125;function arcs:[]&amp;#125;;return t.forEach ( function ( t ) &amp;#123;var a = [];t.forEach ( function ( t, n ) &amp;#123;var o = t[0]&amp;lt;t[1]?t.join ( &amp;quot;, &amp;quot; ) :t[1]+&amp;quot;, &amp;quot;+t[0], s = t.map ( function ( t ) &amp;#123;return e[t]&amp;#125; ) ;o function length ) throw new RangeError ( &amp;quot;Can&amp;#39;t collapse topology into &amp;quot;+n+&amp;quot; function un ( t, n ) &amp;#123;return hn ( sn ( cn ( t ) , t ) , n ) &amp;#125;function n[r+2]], [n[r+2], n[r]]] ) ;return e&amp;#125;function fn ( t, n ) &amp;#123;if ( t.length&amp;gt;8 ) return t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;var e = t.map ( function ( t ) &amp;#123;return n.map ( function ( n ) &amp;#123;return pn ( t, n ) &amp;#125; ) &amp;#125; ) ;return ln ( t, n, e ) &amp;#125;function ln ( t, n, e ) &amp;#123;function r ( t, n, o ) &amp;#123;void 0 =  =  = n&amp;amp;&amp;amp; ( n = [] ) , void 0 =  =  = o&amp;amp;&amp;amp; ( o = 0 ) ;for ( var s = 0;s&amp;lt;t.length;s++ ) &amp;#123;var var i = 1/0, a = t.map ( function ( t, n ) &amp;#123;return n&amp;#125; ) ;return r ( a ) , a&amp;#125;function pn ( t, n ) &amp;#123;var e = N ( J ( t ) , J ( n )  ) ;return e*e&amp;#125;function vn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = ut ( t, r ) ;o.length&amp;lt;n.length+2&amp;amp;&amp;amp;st ( o, n.length+2-o.length ) ;var s, h = un ( o, n.length ) , u = n.map ( function ( t ) &amp;#123;return ut ( t, r ) &amp;#125; ) , c = &amp;quot;string&amp;quot; =  = typeof t&amp;amp;&amp;amp;t;return function gn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) ;var o = vn ( n, t, &amp;#123;maxSegmentLength:r, string:i, single:a&amp;#125; ) ;return a?function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;:o.map ( function ( t ) &amp;#123;return function ( n ) &amp;#123;return t ( 1-n ) &amp;#125;&amp;#125; ) &amp;#125;function xn ( t, n, e ) &amp;#123;void 0 =  =  = e&amp;amp;&amp;amp; ( e = &amp;#123;&amp;#125; ) ;var r = e.maxSegmentLength;void 0 =  =  = r&amp;amp;&amp;amp; ( r = 10 ) ;var i = e.string;void 0 =  =  = i&amp;amp;&amp;amp; ( i = !0 ) ;var a = e.single;if ( void 0 =  =  = a&amp;amp;&amp;amp; ( a = !1 ) , !Array.isArray ( t ) ||!Array.isArray ( n ) ||t.length! =  = n.length||!t.length ) throw new TypeError ( Wn ) ;var o, s, h = function ( t ) &amp;#123;return #125;function yn ( t, n, e ) &amp;#123;void isArray ( a ) &amp;amp;&amp;amp; ( a = a.join ( &amp;quot; &amp;quot; )  ) , Array.isArray ( o ) &amp;amp;&amp;amp; ( o = o.join ( &amp;quot; &amp;quot; )  )  ) , i ) &amp;#123;var c = r?function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return n ( t ) &amp;#125; ) .join ( &amp;quot; &amp;quot; ) &amp;#125;:function ( t ) &amp;#123;return u.map ( function ( n ) &amp;#123;return  =  = typeof t&amp;amp;&amp;amp;t&amp;#125; ) :[], u.map ( function ( t, n ) &amp;#123;return a[n]||o[n]?function ( e ) &amp;#123;return e&amp;lt;1e-4&amp;amp;&amp;amp;a[n]||1-e&amp;lt;1e-4&amp;amp;&amp;amp;o[n]||t ( e ) &amp;#125;:t&amp;#125; )  ) :u&amp;#125;function dn ( t, n, e, r, i ) &amp;#123;return bn ( Ln ( t, n, e ) , r, qn ( t, n, e ) , 2*Math.PI*e, i ) &amp;#125;function mn ( t, n, e, r, i ) &amp;#123;var a = dn ( n, e, r, t, i ) ;return function ( t ) &amp;#123;return a ( 1-t ) &amp;#125;&amp;#125;function Mn ( t, n, e, r, i, a ) &amp;#123;return bn ( An ( t, n, e, r ) , i, _n ( t, n, e, r ) , 2*e+2*r, a ) &amp;#125;function wn ( t, n, e, r, i, a ) &amp;#123;var o = Mn ( n, e, r, i, t, a ) ;return function ( t ) &amp;#123;return o ( 1-t ) &amp;#125;&amp;#125;function bn ( t, n, e, r, i ) &amp;#123;void 0 =  =  = i&amp;amp;&amp;amp; ( i = &amp;#123;&amp;#125; ) ;var a = i.maxSegmentLength;void 0 =  =  = a&amp;amp;&amp;amp; ( a = 10 ) ;var o = i.string;void return t&amp;lt;1e-4?e:h ( t ) &amp;#125;:h&amp;#125;function Ln ( t, n, e ) &amp;#123;return function ( i ) &amp;#123;var a = J ( i ) , o = r ( i.concat ( [i[0]] )  ) , s = Math.atan2 ( i[0][1]-a[1], i[0][0]-a[0] ) , h = 0;return i.map ( function ( r, a ) &amp;#123;var u;return a&amp;amp;&amp;amp; ( h+ = N ( r, i[a-1] )  ) , u = s+2*Math.PI* ( o?h/o:a/i.length ) , [Math.cos ( u ) *e+t, Math.sin ( u ) *e+n]&amp;#125; ) &amp;#125;&amp;#125;function An ( t, n, e, i ) &amp;#123;return function ( a ) &amp;#123;var o = J ( a ) , s = r ( a.concat ( [a[0]] )  ) , h = Math.atan2 ( a[0][1]-o[1], a[0][0]-o[0] ) , u = 0;h&amp;lt;0&amp;amp;&amp;amp; ( h = 2*Math.PI+h ) ;var c = h/ ( 2*Math.PI ) ;return #123;var var #123;var n = new lt;0? ( n.err = &amp;quot;SvgPath: string should start with &amp;#96;M&amp;#96; #123;var t = this;if ( this.cache ) return this.cache;if ( !this.queue.length ) return this.cache = [1, 0, 0, 1, 0, 0], this.cache;if ( this.cache = this.queue[0], 1 =  =  = this.queue.length ) return this.cache;for ( var n = 1;n&amp;lt;this.queue.length;n++ ) t.cache = g ( t.cache, t.queue[n] ) ;return this.cache&amp;#125;</p>
</div>
<div id="body" style="--scroll-prog: 0; margin-left: 0px; width: calc(100% - 0px);"><div id="logo" class="svelte-j0080t"><div id="wrapper "><div id="mainBlob" class="svelte-b931w4"><svg id="visual" viewBox="0 0 900 900" width="100%" height="100%" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="svelte-n5ifpi"><g transform="translate(457.545794298902 440.49383887006405)" opacity="0" class="svelte-n5ifpi"><path id="blob0" d="M167.9 -198.8C235.1 -182.3 319.2 -156.7 340.9 -106.8C362.7 -56.9 322.1 17.3 296.5 96.4C270.9 175.6 260.4 259.7 213.5 285.6C166.5 311.6 83.3 279.3 19.6 252.3C-44.1 225.3 -88.2 203.7 -126.8 175.1C-165.5 146.5 -198.8 110.9 -248.1 57.4C-297.4 3.9 -362.7 -67.6 -362.2 -132.7C-361.7 -197.9 -295.5 -256.7 -224.2 -271.9C-152.8 -287 -76.4 -258.5 -13 -240.6C50.4 -222.6 100.7 -215.3 167.9 -198.8" fill="#ffffff" class="svelte-n5ifpi"></path></g><g transform="rotate(0 0 0) translate(457.545794298902 440.49383887006405) " opacity="0" class="svelte-n5ifpi"><path id="blob1" d="M167.9 -198.8C235.1 -182.3 319.2 -156.7 340.9 -106.8C362.7 -56.9 322.1 17.3 296.5 96.4C270.9 175.6 260.4 259.7 213.5 285.6C166.5 311.6 83.3 279.3 19.6 252.3C-44.1 225.3 -88.2 203.7 -126.8 175.1C-165.5 146.5 -198.8 110.9 -248.1 57.4C-297.4 3.9 -362.7 -67.6 -362.2 -132.7C-361.7 -197.9 -295.5 -256.7 -224.2 -271.9C-152.8 -287 -76.4 -258.5 -13 -240.6C50.4 -222.6 100.7 -215.3 167.9 -198.8" fill="#ffffff" class="svelte-n5ifpi"></path></g><g transform="rotate(0 0 0) translate(457.545794298902 440.49383887006405) " opacity="0" class="svelte-n5ifpi"><path id="blob2" d="M167.9 -198.8C235.1 -182.3 319.2 -156.7 340.9 -106.8C362.7 -56.9 322.1 17.3 296.5 96.4C270.9 175.6 260.4 259.7 213.5 285.6C166.5 311.6 83.3 279.3 19.6 252.3C-44.1 225.3 -88.2 203.7 -126.8 175.1C-165.5 146.5 -198.8 110.9 -248.1 57.4C-297.4 3.9 -362.7 -67.6 -362.2 -132.7C-361.7 -197.9 -295.5 -256.7 -224.2 -271.9C-152.8 -287 -76.4 -258.5 -13 -240.6C50.4 -222.6 100.7 -215.3 167.9 -198.8" fill="#ffffff" class="svelte-n5ifpi"></path></g></svg></div>
    <div id="mainIcon" class="svelte-b931w4"><svg class="main Icon svelte-1jx3d96" width="100%" viewBox="0 0 80 80" version="1.1" id="svg75953" style="--text-color: #ffffff;"><defs id="defs75947"><rect style="--side-color: #c7f347"></rect><clipPath id="clipPath-text-1" clipPathUnits="userSpaceOnUse"><rect y="1.5600179e-05" x="85.215118" height="219.69759" width="117.00888" id="rect863-7" style="fill:#ffffff;stroke:#000000;stroke-width:1.04463;stroke-linecap:round;stroke-linejoin:round;paint-order:markers stroke fill"></rect></clipPath></defs><g id="outer" transform="translate(7,-5.36218) scale(0.8)"><g id="logoSkewLeft" class="logoSkewLeft" style="display:inline" transform="scale(-1, 1) translate(-39.5) skewY(30) translate(39.5) scale(-1, 1)"><g id="layer1" style="display:inline" transform="matrix(0.46573393,0.26889161,0,0.46573393,-6.8217847e-5,-23)"><text xml:space="preserve" id="text77060" style="font-style:normal;font-weight:normal;font-size:10.5833px;line-height:1.25;font-family:sans-serif;white-space:pre;shape-inside:url(#rect77062);fill:#000000;fill-opacity:1;stroke:none;"></text><g id="g1080"><path d="M 85.215112,1e-5 1.5e-4,49.199074 v 98.398136 l 85.214962,49.19906 m 0,0 V 1e-5 196.79627 L 170.43058,147.59721 V 49.199074 L 85.215112,1e-5 m 0,98.398126 L 59.45131,113.2732 V 83.523075 L 33.687005,98.398136 V 128.14826 L 7.9226745,143.02332 V 68.648015 L 33.687005,53.772955 v 29.75012 L 59.45131,68.648015 V 38.898411 l 25.763802,-14.87506 m 51.528638,29.749604 v 29.75012 l -25.76431,-14.87506 z m 0,44.625181 v 29.750124 l -25.76431,14.87506 V 113.2732 Z" style="display:inline;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.517964px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" id="path76540-4-1-9-0-8"></path><path id="path76540-4-1-9-04" style="display:inline;fill-opacity:1;stroke:none;stroke-width:0.517964px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 59.450961,143.0232 -25.76425,-14.875 25.76425,-14.875 z m -25.76425,-44.625004 25.76425,14.875004 -25.76425,14.875 z m 0,-44.625002 25.76425,14.875 -25.76425,14.875 z m 103.056979,0 25.76424,14.875 V 143.0232 l -25.76424,-14.875 z m -25.76425,14.875 25.76425,14.875 V 98.398196 L 110.97944,83.523194 Z m -25.764239,-44.625 25.764239,14.875 V 113.2732 L 85.215201,98.398196 Z" class="svelte-1jx3d96"></path></g></g></g></g></svg></div>
</div></div>
	<section id="section:me" class="svelte-j0080t"><div class="svelte-1wzfvgm"><div id="my-name" class="svelte-1wzfvgm"><div id="glitch-all" style="--delay: 0ms; --amount-top: 40%; --amount-btm: 40%;" class="svelte-9688zt"><div id="glitched1" title="Hannes" class="svelte-9688zt">Hannes</div>
	<div id="glitched2" title="Hannes" class="svelte-9688zt">Hannes</div>
	<div id="glitched3" title="Hannes" class="svelte-9688zt">Hannes</div>
</div>
		
		<div id="glitchwrapper" class="svelte-1a5usdx"><div id="empty"></div>
	<div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="H" class="svelte-9688zt">H</div>
	<div id="glitched2" title="H" class="svelte-9688zt">H</div>
	<div id="glitched3" title="H" class="svelte-9688zt">H</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="a" class="svelte-9688zt">a</div>
	<div id="glitched2" title="a" class="svelte-9688zt">a</div>
	<div id="glitched3" title="a" class="svelte-9688zt">a</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="t" class="svelte-9688zt">t</div>
	<div id="glitched2" title="t" class="svelte-9688zt">t</div>
	<div id="glitched3" title="t" class="svelte-9688zt">t</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="t" class="svelte-9688zt">t</div>
	<div id="glitched2" title="t" class="svelte-9688zt">t</div>
	<div id="glitched3" title="t" class="svelte-9688zt">t</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="e" class="svelte-9688zt">e</div>
	<div id="glitched2" title="e" class="svelte-9688zt">e</div>
	<div id="glitched3" title="e" class="svelte-9688zt">e</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="n" class="svelte-9688zt">n</div>
	<div id="glitched2" title="n" class="svelte-9688zt">n</div>
	<div id="glitched3" title="n" class="svelte-9688zt">n</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="b" class="svelte-9688zt">b</div>
	<div id="glitched2" title="b" class="svelte-9688zt">b</div>
	<div id="glitched3" title="b" class="svelte-9688zt">b</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="a" class="svelte-9688zt">a</div>
	<div id="glitched2" title="a" class="svelte-9688zt">a</div>
	<div id="glitched3" title="a" class="svelte-9688zt">a</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="c" class="svelte-9688zt">c</div>
	<div id="glitched2" title="c" class="svelte-9688zt">c</div>
	<div id="glitched3" title="c" class="svelte-9688zt">c</div>
</div><div id="glitch-all" style="--delay: NaNms; --amount-top: NaN%; --amount-btm: NaN%;" class="svelte-9688zt"><div id="glitched1" title="h" class="svelte-9688zt">h</div>
	<div id="glitched2" title="h" class="svelte-9688zt">h</div>
	<div id="glitched3" title="h" class="svelte-9688zt">h</div>
</div>
</div></div></div>

<div id="description" class="svelte-1wzfvgm"><p class="svelte-1wzfvgm">thats me. I'm currently finishing my computer science degree by writing my master thesis @ Freie Universitt Berlin and developed some love for builing (Web-)Apps. But cryptography and more importantly how to break them using Quantum-Computing is my current interest.</p></div>

<div class="svelte-1wzfvgm"></div>

<div id="placeholder" class="svelte-1wzfvgm">
</div>
		</section><section id="section:education" class="svelte-j0080t"><svg id="visual" viewBox="0 0 900 600" width="100%" height="100%" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="svelte-9s6bof"><path d="M0 398L12.5 394.2C25 390.3 50 382.7 75 388.7C100 394.7 125 414.3 150 414.7C175 415 200 396 225 384C250 372 275 367 300 371.8C325 376.7 350 391.3 375 403.2C400 415 425 424 450 414.8C475 405.7 500 378.3 525 373C550 367.7 575 384.3 600 389.8C625 395.3 650 389.7 675 380.7C700 371.7 725 359.3 750 365.7C775 372 800 397 825 409.8C850 422.7 875 423.3 887.5 423.7L900 424L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#000000" opacity="0.5" class="svelte-9s6bof"></path><path d="M0 445L12.5 439.5C25 434 50 423 75 423.3C100 423.7 125 435.3 150 439.8C175 444.3 200 441.7 225 433.8C250 426 275 413 300 414.3C325 415.7 350 431.3 375 432.7C400 434 425 421 450 418.3C475 415.7 500 423.3 525 420.3C550 417.3 575 403.7 600 402.3C625 401 650 412 675 421.3C700 430.7 725 438.3 750 443.3C775 448.3 800 450.7 825 448.2C850 445.7 875 438.3 887.5 434.7L900 431L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#242424" opacity="0.6" class="svelte-9s6bof"></path><path d="M0 431L12.5 438.3C25 445.7 50 460.3 75 463.2C100 466 125 457 150 452.8C175 448.7 200 449.3 225 446.5C250 443.7 275 437.3 300 434C325 430.7 350 430.3 375 432.3C400 434.3 425 438.7 450 438C475 437.3 500 431.7 525 435.5C550 439.3 575 452.7 600 455.3C625 458 650 450 675 440.5C700 431 725 420 750 423.5C775 427 800 445 825 453.2C850 461.3 875 459.7 887.5 458.8L900 458L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#434343" opacity="0.7" class="svelte-9s6bof"></path><path d="M0 468L12.5 462.3C25 456.7 50 445.3 75 442.8C100 440.3 125 446.7 150 451.8C175 457 200 461 225 459.2C250 457.3 275 449.7 300 450.2C325 450.7 350 459.3 375 461C400 462.7 425 457.3 450 461.8C475 466.3 500 480.7 525 486C550 491.3 575 487.7 600 486.2C625 484.7 650 485.3 675 477.5C700 469.7 725 453.3 750 454.7C775 456 800 475 825 475.7C850 476.3 875 458.7 887.5 449.8L900 441L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#656565" opacity="0.8" class="svelte-9s6bof"></path><path d="M0 494L12.5 492.2C25 490.3 50 486.7 75 486.3C100 486 125 489 150 491.2C175 493.3 200 494.7 225 492.3C250 490 275 484 300 485.5C325 487 350 496 375 502.2C400 508.3 425 511.7 450 510.2C475 508.7 500 502.3 525 497.2C550 492 575 488 600 491.7C625 495.3 650 506.7 675 509.5C700 512.3 725 506.7 750 500C775 493.3 800 485.7 825 485.2C850 484.7 875 491.3 887.5 494.7L900 498L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#898989" opacity="0.9" class="svelte-9s6bof"></path><path d="M0 508L12.5 506.3C25 504.7 50 501.3 75 506.8C100 512.3 125 526.7 150 532.8C175 539 200 537 225 533.8C250 530.7 275 526.3 300 520.7C325 515 350 508 375 508.7C400 509.3 425 517.7 450 518C475 518.3 500 510.7 525 509.3C550 508 575 513 600 518.2C625 523.3 650 528.7 675 532C700 535.3 725 536.7 750 535.2C775 533.7 800 529.3 825 522.8C850 516.3 875 507.7 887.5 503.3L900 499L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#afafaf" opacity="0.8" class="svelte-9s6bof"></path><path d="M0 546L12.5 544.7C25 543.3 50 540.7 75 539.2C100 537.7 125 537.3 150 536.3C175 535.3 200 533.7 225 531.5C250 529.3 275 526.7 300 527.2C325 527.7 350 531.3 375 535C400 538.7 425 542.3 450 545.7C475 549 500 552 525 550.8C550 549.7 575 544.3 600 541C625 537.7 650 536.3 675 534C700 531.7 725 528.3 750 527.3C775 526.3 800 527.7 825 532.5C850 537.3 875 545.7 887.5 549.8L900 554L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#d6d6d6" opacity="0.9" class="svelte-9s6bof"></path><path d="M0 557L12.5 558.8C25 560.7 50 564.3 75 565.2C100 566 125 564 150 564.7C175 565.3 200 568.7 225 571.3C250 574 275 576 300 575.7C325 575.3 350 572.7 375 569.8C400 567 425 564 450 563C475 562 500 563 525 563.5C550 564 575 564 600 566.3C625 568.7 650 573.3 675 574.8C700 576.3 725 574.7 750 572.3C775 570 800 567 825 566.3C850 565.7 875 567.3 887.5 568.2L900 569L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#ffffff" opacity="1" class="svelte-9s6bof"></path></svg>
<div id="content" class="svelte-zwozsm"><h1 class="svelte-zwozsm">Education</h1>
	<p class="svelte-zwozsm">THIS (website) IS STILL WIP</p>
	<p class="svelte-zwozsm">Lorem, ipsum dolor sit amet consectetur adipisicing elit. Quos incidunt eos commodi delectus
		quisquam quibusdam consequuntur. Quasi rem eligendi eius corrupti laudantium assumenda odit
		modi? Molestias a corrupti error enim, fugit fuga unde? Magnam cumque quam dignissimos qui! Ut
		eaque iste illum sequi recusandae laboriosam laborum nisi alias, asperiores libero ratione,
		deleniti dolorem reprehenderit unde eos! Doloremque incidunt neque libero veritatis corporis ad
		assumenda, voluptatum est nisi. Est provident officia facilis nihil fugit error tempora ipsam
		sint, minima nobis. Corrupti accusamus beatae assumenda, sed ea, eius quos numquam iusto
		delectus consectetur, earum molestias fuga aperiam corporis non officia quo similique reiciendis
		rerum vel id nulla optio neque. Nemo unde molestiae porro eveniet corrupti, molestias beatae qui
		quod veritatis fugiat iste eaque harum laboriosam, laudantium libero esse cumque quae numquam
		expedita ratione impedit, repudiandae accusantium? Iusto dolorem accusantium blanditiis laborum
		quae? Delectus similique illum quo odio libero id corporis rerum rem blanditiis voluptatum
		aperiam temporibus error tempora reprehenderit, quidem tempore quisquam sunt ea. At nesciunt
		veniam, velit consectetur eos voluptate, quos recusandae ex, enim hic totam amet dolore tempore.
		Non velit accusamus optio nobis minima qui consequatur quasi voluptates id nisi sequi officiis
		consectetur, laboriosam dolor, eos, quae voluptate blanditiis incidunt tempora cumque
		accusantium ex quia debitis? In, quos maiores? Aperiam fugiat dolorem officia dolor, quibusdam
		ducimus totam nobis earum consequatur voluptatum repellat fuga quo rerum expedita quidem
		voluptas autem culpa porro praesentium vel, cum explicabo sint! Possimus ipsum vel tempora
		blanditiis error sapiente quis similique, sunt corrupti accusantium, vero id animi tempore totam
		fuga ratione cum aliquam debitis deserunt sed? Earum blanditiis a non obcaecati. Minus
		dignissimos voluptate repellendus tempore quam aliquam necessitatibus soluta. Rerum iusto
		accusamus cum vitae repellat possimus consectetur atque dicta est inventore. Quidem numquam
		aliquid, deserunt quo consequatur neque tenetur saepe beatae nisi suscipit deleniti eius! Iste
		modi, maxime ea error consectetur natus non, porro molestias eaque impedit placeat, iure amet.
		Nemo sint vel consequuntur id molestiae excepturi, nisi iure eos velit rerum animi maxime
		possimus sapiente explicabo quia voluptates nesciunt assumenda eius magnam! Porro, laborum esse
		neque voluptate ab ratione sapiente tempora ducimus fugiat, dolorum illo animi? Consequatur ad
		quisquam nobis ut ipsam tenetur ea quos omnis ratione nisi, error perspiciatis delectus soluta
		et eos aut incidunt corporis sed? Architecto nesciunt consequuntur eum ducimus? Vitae
		praesentium vel ullam eveniet, tempora quis voluptatum aperiam consequatur, quisquam delectus
		neque alias tenetur sequi iure nisi itaque provident omnis perspiciatis ipsa repudiandae minima.
		Minus quidem veniam quod voluptatum, placeat temporibus libero debitis recusandae atque itaque.
		Voluptas asperiores blanditiis debitis sunt impedit, veniam id! Harum, tenetur natus veniam
		perspiciatis esse unde dolores amet quibusdam, inventore doloremque quae iure aliquam distinctio
		quas voluptas minus veritatis vero. Velit quis quas repudiandae illo possimus! Beatae adipisci
		odit quas nobis ipsam quos doloremque iusto, quibusdam consequatur officia minima ad totam id
		atque suscipit, blanditiis voluptas tempore hic. Aut, itaque nostrum? Voluptate ab consectetur
		animi sequi obcaecati. Dignissimos obcaecati qui temporibus autem voluptatem enim perferendis
		optio soluta. Exercitationem minus et alias facilis reiciendis, quibusdam qui?
	</p></div>
<div class="flipped svelte-zwozsm"><svg id="visual" viewBox="0 0 900 600" width="100%" height="100%" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="svelte-9s6bof"><path d="M0 398L12.5 394.2C25 390.3 50 382.7 75 388.7C100 394.7 125 414.3 150 414.7C175 415 200 396 225 384C250 372 275 367 300 371.8C325 376.7 350 391.3 375 403.2C400 415 425 424 450 414.8C475 405.7 500 378.3 525 373C550 367.7 575 384.3 600 389.8C625 395.3 650 389.7 675 380.7C700 371.7 725 359.3 750 365.7C775 372 800 397 825 409.8C850 422.7 875 423.3 887.5 423.7L900 424L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#000000" opacity="0.5" class="svelte-9s6bof"></path><path d="M0 445L12.5 439.5C25 434 50 423 75 423.3C100 423.7 125 435.3 150 439.8C175 444.3 200 441.7 225 433.8C250 426 275 413 300 414.3C325 415.7 350 431.3 375 432.7C400 434 425 421 450 418.3C475 415.7 500 423.3 525 420.3C550 417.3 575 403.7 600 402.3C625 401 650 412 675 421.3C700 430.7 725 438.3 750 443.3C775 448.3 800 450.7 825 448.2C850 445.7 875 438.3 887.5 434.7L900 431L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#242424" opacity="0.6" class="svelte-9s6bof"></path><path d="M0 431L12.5 438.3C25 445.7 50 460.3 75 463.2C100 466 125 457 150 452.8C175 448.7 200 449.3 225 446.5C250 443.7 275 437.3 300 434C325 430.7 350 430.3 375 432.3C400 434.3 425 438.7 450 438C475 437.3 500 431.7 525 435.5C550 439.3 575 452.7 600 455.3C625 458 650 450 675 440.5C700 431 725 420 750 423.5C775 427 800 445 825 453.2C850 461.3 875 459.7 887.5 458.8L900 458L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#434343" opacity="0.7" class="svelte-9s6bof"></path><path d="M0 468L12.5 462.3C25 456.7 50 445.3 75 442.8C100 440.3 125 446.7 150 451.8C175 457 200 461 225 459.2C250 457.3 275 449.7 300 450.2C325 450.7 350 459.3 375 461C400 462.7 425 457.3 450 461.8C475 466.3 500 480.7 525 486C550 491.3 575 487.7 600 486.2C625 484.7 650 485.3 675 477.5C700 469.7 725 453.3 750 454.7C775 456 800 475 825 475.7C850 476.3 875 458.7 887.5 449.8L900 441L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#656565" opacity="0.8" class="svelte-9s6bof"></path><path d="M0 494L12.5 492.2C25 490.3 50 486.7 75 486.3C100 486 125 489 150 491.2C175 493.3 200 494.7 225 492.3C250 490 275 484 300 485.5C325 487 350 496 375 502.2C400 508.3 425 511.7 450 510.2C475 508.7 500 502.3 525 497.2C550 492 575 488 600 491.7C625 495.3 650 506.7 675 509.5C700 512.3 725 506.7 750 500C775 493.3 800 485.7 825 485.2C850 484.7 875 491.3 887.5 494.7L900 498L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#898989" opacity="0.9" class="svelte-9s6bof"></path><path d="M0 508L12.5 506.3C25 504.7 50 501.3 75 506.8C100 512.3 125 526.7 150 532.8C175 539 200 537 225 533.8C250 530.7 275 526.3 300 520.7C325 515 350 508 375 508.7C400 509.3 425 517.7 450 518C475 518.3 500 510.7 525 509.3C550 508 575 513 600 518.2C625 523.3 650 528.7 675 532C700 535.3 725 536.7 750 535.2C775 533.7 800 529.3 825 522.8C850 516.3 875 507.7 887.5 503.3L900 499L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#afafaf" opacity="0.8" class="svelte-9s6bof"></path><path d="M0 546L12.5 544.7C25 543.3 50 540.7 75 539.2C100 537.7 125 537.3 150 536.3C175 535.3 200 533.7 225 531.5C250 529.3 275 526.7 300 527.2C325 527.7 350 531.3 375 535C400 538.7 425 542.3 450 545.7C475 549 500 552 525 550.8C550 549.7 575 544.3 600 541C625 537.7 650 536.3 675 534C700 531.7 725 528.3 750 527.3C775 526.3 800 527.7 825 532.5C850 537.3 875 545.7 887.5 549.8L900 554L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#d6d6d6" opacity="0.9" class="svelte-9s6bof"></path><path d="M0 557L12.5 558.8C25 560.7 50 564.3 75 565.2C100 566 125 564 150 564.7C175 565.3 200 568.7 225 571.3C250 574 275 576 300 575.7C325 575.3 350 572.7 375 569.8C400 567 425 564 450 563C475 562 500 563 525 563.5C550 564 575 564 600 566.3C625 568.7 650 573.3 675 574.8C700 576.3 725 574.7 750 572.3C775 570 800 567 825 566.3C850 565.7 875 567.3 887.5 568.2L900 569L900 601L887.5 601C875 601 850 601 825 601C800 601 775 601 750 601C725 601 700 601 675 601C650 601 625 601 600 601C575 601 550 601 525 601C500 601 475 601 450 601C425 601 400 601 375 601C350 601 325 601 300 601C275 601 250 601 225 601C200 601 175 601 150 601C125 601 100 601 75 601C50 601 25 601 12.5 601L0 601Z" fill="#ffffff" opacity="1" class="svelte-9s6bof"></path></svg>
</div>
		</section><section id="section:experience" class="svelte-j0080t"><div id="content" class="svelte-16wqkwh"><h1 class="svelte-16wqkwh">Experience</h1>
	<p class="svelte-16wqkwh">Lorem ipsum dolor sit amet consectetur adipisicing elit. Modi expedita eius ipsa impedit minima
		pariatur eum dolore quas veniam, doloribus aut consectetur distinctio sed sint deserunt
		voluptates facere nisi ducimus dolores explicabo totam. Unde ex libero, et deserunt voluptates
		sit, est nesciunt pariatur iure ea inventore officiis vero rerum. Cupiditate ea dolorum animi
		incidunt possimus explicabo, maiores inventore iure iusto reiciendis sint, sed, quo asperiores
		quibusdam nostrum consectetur cumque! Accusamus consequatur quod dolore quis, ipsa architecto
		enim quidem perspiciatis nostrum optio rerum ad debitis modi laboriosam eum sint eos at beatae
		sapiente. Vel alias facilis omnis quae dolore quod delectus tenetur perferendis! Aliquid ratione
		pariatur sequi. Assumenda ratione aspernatur nihil nemo minus, inventore laudantium ex. Sunt in
		quo saepe unde nisi aperiam eius assumenda deleniti ratione ducimus, eos exercitationem esse
		optio, minima voluptatibus nam tempore nihil officiis explicabo? Et consequatur cupiditate
		sapiente. Consequuntur ad laudantium recusandae, molestiae, illum architecto, quo quas quasi
		esse praesentium vel accusantium eos ex cum? Corporis nemo eveniet sapiente repudiandae repellat
		ex dolores, nesciunt, consequuntur incidunt aliquam quas consectetur eum? Commodi quos quibusdam
		dolorem corrupti culpa fugiat aliquid eum atque facilis ea possimus, dicta laboriosam quis et
		harum officia non accusantium expedita libero, minima perspiciatis saepe maxime assumenda?
		Aperiam repudiandae cumque quidem nostrum officia quisquam quas saepe ex labore praesentium ipsa
		ipsum atque quibusdam recusandae corrupti tenetur adipisci rem, cum voluptatem quod, asperiores
		impedit mollitia totam. Voluptate expedita porro repudiandae dolorum assumenda excepturi
		molestias ipsum itaque inventore officiis iusto cumque minima voluptatibus enim, reiciendis id
		natus deleniti, tempore voluptatem ullam quis est in maiores! Quibusdam autem, id distinctio
		praesentium a est ipsum necessitatibus vero possimus saepe dicta quis atque modi voluptate
		reprehenderit perferendis fuga numquam accusamus odio, iure velit suscipit at? Inventore nihil
		fugit illum? Temporibus natus velit fuga necessitatibus hic? Atque suscipit voluptate aliquam
		sunt, iste architecto odio consequatur, neque illum ex repudiandae obcaecati debitis id nemo
		pariatur dolorum cumque. Cupiditate, rerum! Ipsa itaque nulla culpa cum nam neque atque saepe
		ipsum, voluptatum consequatur dolorum dicta qui, pariatur voluptatibus deleniti similique animi
		reprehenderit earum omnis alias quia cumque quo ex? Ullam tenetur repudiandae deleniti quidem
		rerum repellat eius voluptatem commodi ratione dicta obcaecati ipsum voluptas aut esse
		laboriosam veritatis voluptate inventore ipsa mollitia architecto, fuga debitis. Maxime rem
		suscipit libero, veritatis fuga explicabo ad accusantium quaerat qui nihil, expedita placeat
		corporis exercitationem vitae aliquam. Harum dolor iste cumque optio repellat, aut natus
		delectus ex, dolore libero, cupiditate sit voluptatem adipisci hic nihil? Dolore molestiae
		beatae modi consectetur necessitatibus, soluta laborum dolores eos, fugiat sint voluptatem magni
		corrupti enim labore in ut recusandae assumenda? Quas, illo. Pariatur omnis atque nesciunt
		reiciendis tempore quas harum modi, repellat quisquam corrupti expedita qui culpa assumenda nemo
		quos, eveniet unde rem temporibus. Eius eligendi, temporibus optio est magnam voluptate nemo
		enim, sunt animi ullam eum eveniet consectetur! Atque minima sint qui corrupti adipisci,
		pariatur similique exercitationem perferendis iste aliquam quas vero rerum, dolore maiores
		maxime ea est tempore libero enim eos laborum sed a. Eaque numquam quidem exercitationem nisi
		eius!
	</p>
</div>
		</section><section id="section:skills" class="svelte-j0080t"><div id="content" class="svelte-1dk9v3c"><h1 class="svelte-1dk9v3c">Skills</h1>
    <div id="skills" class="svelte-1dk9v3c"><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-vscode-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">VS Code</h2>
	<div id="level" style="--skill: 100%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-git-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Git</h2>
	<div id="level" style="--skill: 90%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-github-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">GitHub</h2>
	<div id="level" style="--skill: 100%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-typescript-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">TypeScript</h2>
	<div id="level" style="--skill: 80%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-python-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Python</h2>
	<div id="level" style="--skill: 70%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-flutter-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Flutter</h2>
	<div id="level" style="--skill: 100%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-dart-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Dart</h2>
	<div id="level" style="--skill: 100%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-svelte-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Svelte</h2>
	<div id="level" style="--skill: 80%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-android-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Android</h2>
	<div id="level" style="--skill: 50%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-arduino-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Arduino</h2>
	<div id="level" style="--skill: 80%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-bash-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Bash</h2>
	<div id="level" style="--skill: 40%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-cplusplus-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">C++</h2>
	<div id="level" style="--skill: 50%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-sass-original svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Sass</h2>
	<div id="level" style="--skill: 80%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-linux-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Linux</h2>
	<div id="level" style="--skill: 50%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-postgresql-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">PostgreSQL</h2>
	<div id="level" style="--skill: 30%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-nodejs-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">NodeJS</h2>
	<div id="level" style="--skill: 90%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-swift-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Swift</h2>
	<div id="level" style="--skill: 40%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-vuejs-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Vue</h2>
	<div id="level" style="--skill: 20%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-unity-original svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Unity</h2>
	<div id="level" style="--skill: 40%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-latex-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">LaTeX</h2>
	<div id="level" style="--skill: 70%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div><div id="skill" class="svelte-kvwvj"><i id="icon" class="devicon-rust-plain svelte-kvwvj"></i>
	<h2 id="name" class="svelte-kvwvj">Rust</h2>
	<div id="level" style="--skill: 10%; --progress-color: #fff;" class="svelte-kvwvj"><div class="progress svelte-kvwvj"><div class="progress-value svelte-kvwvj"></div></div></div>
</div></div>
</div>
		</section><section id="section:projects" class="svelte-j0080t">
		</section><section id="section:contact" class="svelte-j0080t">
		</section></div>

<div id="elemts-row" style="height:60px" class="svelte-fzmbic"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>

<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Home</button>
	<div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Me</button>
		</div><div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Education</button>
		</div><div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Experience</button>
		</div><div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Skills</button>
		</div><div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Projects</button>
		</div><div class="smooth svelte-j0080t"><div id="defs" style="--color: white" class="svelte-yq15vr"></div>


	<button class="navElem  mdc-button__ripple mdc-button--unelevated svelte-yq15vr">Contact</button>
		</div></div>
<div id="wrapper" style="--color: #a7c347; --progress: 0; width: calc(0px + 100%); height: calc(590.7692307692308px + 0%);" class="svelte-fzmbic"><svg height="100%" stroke-miterlimit="10" style="fill-rule:nonzero;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;" version="1.1" viewBox="0 0 1024 1024" preserveAspectRatio="none" pointer-events="none" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><clipPath id="ArtboardFrame"><rect height="100%" width="100%" x="0" y="0"></rect></clipPath><g clip-path="url(#ArtboardFrame)" id="Layer-1"><path id="main" d="M-73.6978 920.009L1094.31 920.009C1149.02 920.009 1193.37 964.357 1193.37 1019.06L1193.37 1043.08C1193.37 1097.79 1149.02 1142.14 1094.31 1142.14L-73.6978 1142.14C-128.405 1142.14-172.753 1097.79-172.753 1043.08L-172.753 1019.06C-172.753 964.357-128.405 920.009-73.6978 920.009Z" fill-rule="nonzero" opacity="1" stroke="none" class="svelte-fzmbic"></path></g></svg></div>


<div class="flexy svelte-1mt66fb"><div class="wrapper svelte-1mt66fb"><button class="mdc-fab mdc-fab--exited" style=""><div class="mdc-fab__ripple"></div>
  <i class="material-icons mdc-fab__icon" aria-hidden="true">arrow_upward</i></button></div></div>






		<script type="module" data-sveltekit-hydrate="y1b7dc">
			import { start } from "./_app/immutable/start-badb6dfc.js";

			start({
				env: {},
				hydrate: {
					status: 200,
					error: null,
					node_ids: [0, 2],
					params: {},
					routeId: "",
					data: (function(a){return [a,a]}(null)),
					form: null
				},
				paths: {"base":"","assets":""},
				target: document.querySelector('[data-sveltekit-hydrate="y1b7dc"]').parentNode,
				trailing_slash: "never"
			});
		</script>
	</div>
	</body>
</html>
